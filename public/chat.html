<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>OHmegle - Chat</title>
    <script src="/socket.io/socket.io.js"></script> 
    <style>
        body { font-family: Arial, sans-serif; display: flex; justify-content: center; align-items: center; min-height: 100vh; margin: 0; background-color: #f0f2f5; }
        .chat-container { 
            background-color: white; 
            padding: 20px; 
            border-radius: 10px; 
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1); 
            width: 90%; 
            max-width: 800px;
            display: flex; 
            flex-direction: column; 
            height: 90vh;
        }
        
        #video-streams {
            flex-grow: 1;
            width: 100%; 
            margin-bottom: 10px; 
            background-color: black; 
            display: flex;
            overflow: hidden;
        }
        
        #local-video, #remote-video {
            width: 50%;
            height: 100%; 
            object-fit: cover;
            border: 1px solid #333;
        }
        
        #messages-area {
            flex-grow: 1;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            border: 1px solid #eee; 
            margin-bottom: 10px;
        }
        
        #messages { 
            flex-grow: 1; 
            padding: 10px; 
            overflow-y: scroll; 
            list-style-type: none; 
            margin: 0; 
        }
        
        #messages li { padding: 5px 0; border-bottom: 1px dotted #eee; }
        #messages .self { text-align: right; color: #007bff; }
        #messages .partner { text-align: left; color: #ff5722; }
        #messages .system { text-align: center; font-style: italic; color: #6c757d; }
        
        #status { text-align: center; margin-bottom: 5px; }
        #typing-status {
            font-style: italic; 
            color: #777; 
            height: 18px; 
            padding: 0 10px 5px 10px;
        }

        #input-form { display: flex; }
        #input-form input { flex-grow: 1; padding: 10px; border: 1px solid #ccc; border-radius: 5px 0 0 5px; }
        #input-form button { padding: 10px 15px; background-color: #ff5722; color: white; border: none; border-radius: 0 5px 5px 0; cursor: pointer; }
        
        .controls { display: flex; justify-content: space-between; margin-bottom: 10px; }
        .controls button { padding: 10px 15px; border: none; border-radius: 5px; cursor: pointer; color: white; font-weight: bold; }
        #skipBtn { background-color: #007bff; }
        #stopBtn { background-color: #dc3545; }
        #videoSwitchBtn { background-color: #4CAF50; }
    </style>
</head>
<body>

    <div class="chat-container">
        <div class="controls">
            <button id="skipBtn" onclick="disconnectChat()">Skip</button>
            <button id="videoSwitchBtn" style="display: none;" onclick="startVideo(false)">Switch to Video</button>
            <button id="stopBtn" onclick="stopChat()">Stop</button>
        </div>
        
        <div id="status">Connecting...</div>
        
        <div id="video-streams" style="display: none;">
            <video id="local-video" autoplay muted playsinline></video>
            <video id="remote-video" autoplay playsinline></video>
        </div>
        
        <div id="messages-area">
            <ul id="messages">
            </ul>
            <div id="typing-status"></div>
        </div>
        
        <form id="input-form">
            <input id="m" autocomplete="off" placeholder="Type a message..." disabled/>
            <button type="submit" disabled>Send</button>
        </form>
    </div>

    <script>
        const socket = io();
        
        const form = document.getElementById('input-form');
        const input = document.getElementById('m');
        const messagesArea = document.getElementById('messages-area');
        const messages = document.getElementById('messages');
        const statusDiv = document.getElementById('status');
        const sendBtn = form.querySelector('button');
        const typingStatusDiv = document.getElementById('typing-status');
        const videoStreamsDiv = document.getElementById('video-streams');
        const videoSwitchBtn = document.getElementById('videoSwitchBtn');
        const localVideo = document.getElementById('local-video');
        const remoteVideo = document.getElementById('remote-video');

        let typingTimeout;
        let localStream;
        let peerConnection;
        let isVideoChat = localStorage.getItem('chatType') === 'video';
        
        const stunServers = [{ urls: 'stun:stun.l.google.com:19302' }];
        
        document.addEventListener('DOMContentLoaded', () => {
            const interests = localStorage.getItem('userInterests') || 'General';
            statusDiv.textContent = `Looking for a match with interests: ${interests}...`;
            
            if (isVideoChat) {
                videoStreamsDiv.style.display = 'flex';
                messagesArea.style.display = 'none';
                videoSwitchBtn.style.display = 'none'; 
            } else {
                videoStreamsDiv.style.display = 'none';
                messagesArea.style.display = 'flex';
                videoSwitchBtn.style.display = 'inline-block';
            }

            socket.emit('start_chat', interests, isVideoChat);
        });

        input.addEventListener('input', () => {
            if (!input.disabled) {
                socket.emit('typing');
                clearTimeout(typingTimeout);
                typingTimeout = setTimeout(() => {
                    socket.emit('stop_typing');
                }, 1000);
            }
        });

        socket.on('match_found', () => {
            statusDiv.textContent = isVideoChat ? "Partner found! Attempting video connection..." : "You are connected with a stranger! Say hello!";
            input.disabled = false;
            sendBtn.disabled = false;
            
            messages.innerHTML = ''; 
            typingStatusDiv.textContent = "";

            if (isVideoChat) {
                startVideo(true);
            }
        });

        socket.on('partner_disconnected', () => {
            statusDiv.textContent = "Your partner disconnected. Searching for a new stranger...";
            input.disabled = true; 
            sendBtn.disabled = true;
            appendMessage('System: Your partner disconnected. Looking for a new match.', 'system');
            
            typingStatusDiv.textContent = "";
            cleanupVideo();
            
            socket.emit('start_chat', localStorage.getItem('userInterests') || 'General', isVideoChat); 
        });

        socket.on('chat_message', (msg) => {
            typingStatusDiv.textContent = ""; 
            appendMessage(`Stranger: ${msg}`, 'partner');
        });
        socket.on('chat_message_self', (msg) => {
            appendMessage(`You: ${msg}`, 'self');
        });
        socket.on('partner_typing', () => {
            typingStatusDiv.textContent = "Stranger is typing...";
            messages.scrollTop = messages.scrollHeight; 
        });
        socket.on('partner_stop_typing', () => {
            typingStatusDiv.textContent = "";
        });

        socket.on('call_made', async (offer) => {
            if (!peerConnection) {
                 await startVideo(true, offer);
                 return;
            }
            await peerConnection.setRemoteDescription(new RTCSessionDescription(offer));
            const answer = await peerConnection.createAnswer();
            await peerConnection.setLocalDescription(answer);
            socket.emit('answer_call', peerConnection.localDescription);
        });

        socket.on('answer_received', (answer) => {
            peerConnection.setRemoteDescription(new RTCSessionDescription(answer));
        });

        socket.on('ice_candidate_received', (candidate) => {
            if (peerConnection) {
                peerConnection.addIceCandidate(new RTCIceCandidate(candidate));
            }
        });

        form.addEventListener('submit', (e) => {
            e.preventDefault();
            if (input.value && !input.disabled) {
                clearTimeout(typingTimeout);
                socket.emit('stop_typing');

                socket.emit('chat_message', input.value);
                input.value = '';
            }
        });

        async function startVideo(isInitialCall = false, offer = null) {
            if (localStream) return; 

            try {
                localStream = await navigator.mediaDevices.getUserMedia({ video: true, audio: true });
                localVideo.srcObject = localStream;

                videoStreamsDiv.style.display = 'flex';
                messagesArea.style.display = 'none';
                videoSwitchBtn.style.display = 'none';
                statusDiv.textContent = "Video connected locally. Waiting for partner...";
                
                isVideoChat = true;

                peerConnection = new RTCPeerConnection({ iceServers: stunServers });
                localStream.getTracks().forEach(track => peerConnection.addTrack(track, localStream));

                peerConnection.ontrack = (event) => {
                    remoteVideo.srcObject = event.streams[0];
                    statusDiv.textContent = "Video chat established!";
                };

                peerConnection.onicecandidate = (event) => {
                    if (event.candidate) {
                        socket.emit('ice_candidate', event.candidate);
                    }
                };

                if (offer) {
                    await peerConnection.setRemoteDescription(new RTCSessionDescription(offer));
                    const answer = await peerConnection.createAnswer();
                    await peerConnection.setLocalDescription(answer);
                    socket.emit('answer_call', peerConnection.localDescription);
                } else if (isInitialCall || !isVideoChat) {
                    const newOffer = await peerConnection.createOffer();
                    await peerConnection.setLocalDescription(newOffer);
                    socket.emit('call_user', peerConnection.localDescription);
                }

            } catch (error) {
                console.error("Error accessing media devices or starting video:", error);
                statusDiv.textContent = "Error: Camera/Mic access denied or failed. Reverting to text chat.";
                cleanupVideo();
                isVideoChat = false;
            }
        }

        function cleanupVideo() {
            if (localStream) {
                localStream.getTracks().forEach(track => track.stop());
                localStream = null;
            }
            if (peerConnection) {
                peerConnection.close();
                peerConnection = null;
            }
            localVideo.srcObject = null;
            remoteVideo.srcObject = null;
            videoStreamsDiv.style.display = 'none';
            messagesArea.style.display = 'flex'; 
            videoSwitchBtn.style.display = 'inline-block';
        }

        function disconnectChat() {
            socket.emit('disconnect_chat'); 
            statusDiv.textContent = "Chat ended. Looking for a new stranger...";
            input.disabled = true; 
            sendBtn.disabled = true;
            appendMessage('System: Chat ended by user. Looking for a new match.', 'system');

            messages.innerHTML = '';
            typingStatusDiv.textContent = "";
            cleanupVideo();

            socket.emit('start_chat', localStorage.getItem('userInterests') || 'General', isVideoChat); 
        }

        function stopChat() {
            socket.emit('disconnect_chat'); 
            cleanupVideo();
            window.location.href = 'index.html';
        }
        
        function appendMessage(text, className) {
            const item = document.createElement('li');
            item.textContent = text;
            item.classList.add(className);
            messages.appendChild(item);
            messages.scrollTop = messages.scrollHeight; 
        }
    </script>

</body>
</html>